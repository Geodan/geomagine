<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="./gm-cow-core.html">
<dom-module id="app-instance">
    <template>
    </template>
</dom-module>
<script>

Polymer({
    is: 'app-instance',
    properties:{
        cow: {
            type: Object,
            observer: '_cowChanged'
        },
        team: {
            type: String,
            notify: true
        },
        scenario: {
            type: String
        },
        type: {
            type: String
        },
        kaartjes: {
            type:Array,
            value: function(){
                return [];
            },
            notify: true
        },
        verbindingen: {
            type: Array,
            value: function(){
                return [];
            },
            notify: true
        },
        eigenschappen: {
            type: Array,
            value: function(){
                return [];
            },
            notify: true
        },
        progress: {
            type: Number,
            value: 0,
            notify: true
        },
        project_ready: { // Promise
            type: Object,
            notify: true
        },
        _project: {
            type: Object
        },
        _cowProgress: {
            type: Object
        }
    },
    observers: [
        '_teamChanged(team, _project)',
        '_scenarioChanged(scenario, _project)',
        '_typeChanged(type, _project)',
        '_projectChanged(_project)'
    ],
    _cowChanged: function() {
        if (!this.cow) return;
        console.log('_cowChanged');

        this._waitForProject();

        var self = this;
        if (this.type !== 'eerstescherm') {
            this.project_ready.then(function () {
                this.cow.peerStore().on('datachange', function () {
                    var peers = self.cow.peers().filter(function (d) {
                        return !d.deleted() && d.id() !== self.cow.peerid() &&
                                d.data('type') === 'eerstescherm' && d.data('scenario') === self.scenario;
                    });
                    if (peers.length > 0) {
                        var newTeam = peers[0].data('team');
                        if (self.team !== newTeam) {
                            self.team = newTeam;
                        }
                    }
                });
            });
        }
    },
    _projectChanged: function() {
        this._reset();
        if (this._project) {
            var self = this;
            this._project.on('datachange', function() {
                if (self._project.deleted()) {
                    // project closed
                    self._project.off('datachange');
                    self._project = null; // TODO: will this prevent observers from firing? Maybe not so bad
                    console.log('Project closed, waiting for new project...');
                    self._waitForProject();
                    self.fire('projectclosed');
                }
            });
        }
    },
    _waitForProject: function() {
        var self = this;

        function findProject(resolve) {
            var projects = self.cow.projects().filter(function (d) {
                return !d.deleted();
            });
            if (projects.length === 0) {
                return false;
            } else if (projects.length > 1) {
                projects.sort(function (a, b) {
                    return b.created() - a.created();
                });
            }
            self._project = projects[0];
            self._itemsChanged();
            if (!self._project_ready_resolved && self._checkProject()) {
                resolve();
            }
            self._project.itemStore().on('datachange', function () {
                self._itemsChanged();
                if (!self._project_ready_resolved && self._checkProject()) {
                    resolve();
                }
            });
            return true;
        }

        self._project_ready_resolved = false;
        self.project_ready = new Promise(function(resolve, reject){
            if (!findProject(resolve)) {

                // project is not yet loaded, wait for it...
                self.cow.projectStore().on('datachange', function() {
                    if (findProject(resolve)) {
                        self.cow.projectStore().off('datachange'); // disable event listener when project is found
                    }
                });
            }
        }).then(function(){
            self._project_ready_resolved = true;
        })
    },
    _checkProject: function() {
        if (!this._project) {
            return false;
        }

        var project = this._project;
        var items = project.items();

        console.log('scenarios: ' + items.filter(function(d) { return d.data('type') === 'scenario' }).length + ' of ' + project.data('numScenarios'));
        console.log('teams: ' + items.filter(function(d) { return d.data('type') === 'team' }).length + ' of ' + project.data('numTeams'));
        console.log('eigenschappen: ' + items.filter(function(d) { return d.data('type') === 'eigenschap' }).length + ' of ' + project.data('numEigenschappen'));
        console.log('kaartjes: ' + items.filter(function(d) { return d.data('type') === 'kaartje' }).length + ' of ' + project.data('numKaartjes'));
        console.log('verbindingen: ' + items.filter(function(d) { return d.data('type') === 'verbinding' }).length + ' of ' + project.data('numVerbindingen'));
        console.log('progress: ' + items.filter(function(d) { return d.data('type') === 'progress' }).length + ' of ' + project.data('numProgress'));

        return items.filter(function(d) { return d.data('type') === 'scenario' }).length === project.data('numScenarios') &&
                items.filter(function(d) { return d.data('type') === 'team' }).length === project.data('numTeams') &&
                items.filter(function(d) { return d.data('type') === 'eigenschap' }).length === project.data('numEigenschappen') &&
                items.filter(function(d) { return d.data('type') === 'kaartje' }).length === project.data('numKaartjes') &&
                items.filter(function(d) { return d.data('type') === 'verbinding' }).length === project.data('numVerbindingen') &&
                items.filter(function(d) { return d.data('type') === 'progress' }).length === project.data('numProgress');
    },
    _itemsChanged: function() {
        var self = this;
        if (!this._project || !this.team || !this.scenario) {
            return;
        }

        var myItems = self._project.items().filter(function(d){
            return !d.deleted() && d.data('team') === self.team && d.data('scenario') === self.scenario;
        });

        self.eigenschappen = myItems.filter(function(d){
            return d.data('type') === 'eigenschap';
        });
        // make sure Polymer listeners are triggered
        self.eigenschappen.forEach(function(d,i){
            self.set('eigenschappen.'+i+'._data.found',d.data('found'));
        });
        //TODO: maybe set the 'found' to false for every eigenschap

        self.kaartjes = myItems.filter(function(d){
            return d.data('type') === 'kaartje';
        });
        // make sure Polymer listeners are triggered
        self.kaartjes.forEach(function(d,i){
            self.set('kaartjes.'+i+'._data.x',d.data('x'));
            self.set('kaartjes.'+i+'._data.y',d.data('y'));
        });

        self.verbindingen = myItems.filter(function(d){
            return d.data('type')==='verbinding';
        });
        // make sure Polymer listeners are triggered
        self.verbindingen.forEach(function(d,i){
            self.set('verbindingen.'+i+'._data.vanid',d.data('vanid'));
            self.set('verbindingen.'+i+'._data.naarid',d.data('naarid'));
        });

        var progress = myItems.filter(function (d) {
            return d.data('type') === 'progress';
        });
        if (progress.length > 0) {
            self._cowProgress = progress[0];
            self.progress = self._cowProgress.data('value');
        }

        self._calculateScore();
    },
    _reset: function() {
        this.progress = 0;
        this.kaartjes = [];
        this.verbindingen = [];
        this.eigenschappen = [];
    },
    _teamChanged: function(team, _project) {
        var self = this;
        this.project_ready.then(function() {
            self._reset();
            console.log('_teamChanged');

            /*  We probably don't need to check for duplicate teams, plus it might cause unwanted restrictions
                when teams move from one table to the next
            if (self.team && self.type === 'eerstescherm') {
                var peers = self.cow.peers().filter(function (d) {
                    return !d.deleted() && d.id() !== self.cow.peerid() &&
                            d.data('type') === 'eerstescherm' && d.data('user') === self.team;
                });
                if (peers.length > 0) {
                    console.log('Team ' + self.team + ' is already playing on another peer');
                    // TODO: handle duplicate team
                    self.team = null;
                    return;
                }
            }*/

            self.cow.peer().data('team', self.team).sync();
            self._itemsChanged();
        });
    },
    _scenarioChanged: function(scenario, _project) {
        var self = this;
        this.project_ready.then(function() {
            console.log('_scenarioChanged: ' + scenario);
            self._reset();

            if (self.scenario && self.type === 'eerstescherm') {
                var peers = self.cow.peers().filter(function (d) {
                    return !d.deleted() && d.id() !== self.cow.peerid() &&
                            d.data('type') === 'eerstescherm' && d.data('scenario') === self.scenario;
                });
                if (peers.length > 0) {
                    console.log('There is another peer playing scenario ' + self.scenario);
                    // TODO: handle duplicate scenario
                    self.scenario = null;
                    return;
                }
            }

            self.cow.peer().data('scenario', self.scenario).sync();
            self._itemsChanged();
        });
    },
    _typeChanged: function(type, _project) {
        var self = this;
        this.project_ready.then(function() {
            console.log('_typeChanged: ' + type);
            self.cow.peer().data('type', self.type).sync();
        });
    },
    setProgress: function(progress){
        var self = this;
        this.project_ready.then(function() {
            self._cowProgress.data('value', progress).sync();
        });
    },
    _calculateScore: function() {
        // TODO
    },
    attached: function() {
        console.log('app-instance attached');
    }
});
</script>